/* tslint:disable */
/* eslint-disable */
/**
 * M-Advise
 * This API provides access to the M-Advise service.
 *
 * The version of the OpenAPI document: latest
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import { DUMMY_BASE_URL, assertParamExists, createRequestFunction, serializeDataIfNeeded, setSearchParams, toPathString } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Appointment
 */
export interface Appointment {
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  summary?: string;
  /**
   *
   * @type {Doctor}
   * @memberof Appointment
   */
  organizer?: Doctor;
  /**
   *
   * @type {Patient}
   * @memberof Appointment
   */
  participant?: Patient;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  from?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  to?: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  roomId?: string;
}
/**
 *
 * @export
 * @interface BadRequestException
 */
export interface BadRequestException {
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Channel
 */
export interface Channel {
  /**
   *
   * @type {string}
   * @memberof Channel
   */
  id?: string;
  /**
   * Identifier of the person who send the first message
   * @type {string}
   * @memberof Channel
   */
  creator?: string;
  /**
   * Identifier of the receiver
   * @type {string}
   * @memberof Channel
   */
  invited?: string;
}
/**
 *
 * @export
 * @interface Department
 */
export interface Department {
  /**
   *
   * @type {string}
   * @memberof Department
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Department
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Department
   */
  contact?: string;
  /**
   *
   * @type {DepartmentAdvisor}
   * @memberof Department
   */
  advisor?: DepartmentAdvisor;
}
/**
 *
 * @export
 * @interface DepartmentAdvisor
 */
export interface DepartmentAdvisor {
  /**
   *
   * @type {User}
   * @memberof DepartmentAdvisor
   */
  schemas?: User;
}
/**
 *
 * @export
 * @interface Doctor
 */
export interface Doctor {
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  branch?: string;
  /**
   *
   * @type {Department}
   * @memberof Doctor
   */
  department?: Department;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  registryNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  authenticationId?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  birthDate?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  photoId?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  sex?: DoctorSexEnum;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  contact?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Doctor
   */
  role?: DoctorRoleEnum;
}

export const DoctorSexEnum = {
  Male: 'MALE',
  Feminine: 'FEMININE',
} as const;

export type DoctorSexEnum = (typeof DoctorSexEnum)[keyof typeof DoctorSexEnum];
export const DoctorRoleEnum = {
  Advisor: 'ADVISOR',
  Doctor: 'DOCTOR',
  Patient: 'PATIENT',
} as const;

export type DoctorRoleEnum = (typeof DoctorRoleEnum)[keyof typeof DoctorRoleEnum];

/**
 *
 * @export
 * @interface Exception
 */
export interface Exception {
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Exception
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Feedback
 */
export interface Feedback {
  /**
   *
   * @type {Patient}
   * @memberof Feedback
   */
  sender?: Patient;
  /**
   *
   * @type {string}
   * @memberof Feedback
   */
  comment?: string;
  /**
   *
   * @type {number}
   * @memberof Feedback
   */
  score?: number;
  /**
   *
   * @type {string}
   * @memberof Feedback
   */
  creationDatetime?: string;
}
/**
 *
 * @export
 * @interface FeedbackSummary
 */
export interface FeedbackSummary {
  /**
   *
   * @type {number}
   * @memberof FeedbackSummary
   */
  totalFeedbacks?: number;
  /**
   *
   * @type {number}
   * @memberof FeedbackSummary
   */
  totalScore?: number;
  /**
   *
   * @type {Array<Feedback>}
   * @memberof FeedbackSummary
   */
  feedbacks?: Array<Feedback>;
}
/**
 *
 * @export
 * @interface GenerateToken200Response
 */
export interface GenerateToken200Response {
  /**
   *
   * @type {string}
   * @memberof GenerateToken200Response
   */
  token?: string;
  /**
   * expiration date-time in seconds
   * @type {number}
   * @memberof GenerateToken200Response
   */
  expiresIn?: number;
}
/**
 *
 * @export
 * @interface GenerateTokenRequest
 */
export interface GenerateTokenRequest {
  /**
   *
   * @type {number}
   * @memberof GenerateTokenRequest
   */
  appId?: number;
  /**
   *
   * @type {string}
   * @memberof GenerateTokenRequest
   */
  appSecret?: string;
  /**
   *
   * @type {string}
   * @memberof GenerateTokenRequest
   */
  username?: string;
}
/**
 *
 * @export
 * @interface Hospital
 */
export interface Hospital {
  /**
   *
   * @type {string}
   * @memberof Hospital
   */
  nif?: string;
  /**
   *
   * @type {string}
   * @memberof Hospital
   */
  stat?: string;
  /**
   *
   * @type {string}
   * @memberof Hospital
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Hospital
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Hospital
   */
  contact?: string;
  /**
   *
   * @type {DepartmentAdvisor}
   * @memberof Hospital
   */
  advisor?: DepartmentAdvisor;
}
/**
 *
 * @export
 * @interface InternalServerException
 */
export interface InternalServerException {
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InternalServerException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface MedicalInfo
 */
export interface MedicalInfo {
  /**
   *
   * @type {Patient}
   * @memberof MedicalInfo
   */
  patient?: Patient;
  /**
   *
   * @type {PatientAdditionalInfo}
   * @memberof MedicalInfo
   */
  patientAdditionalInfo?: PatientAdditionalInfo;
  /**
   *
   * @type {Array<MedicalInfoContinualPostoperativeInner>}
   * @memberof MedicalInfo
   */
  continualPostoperative?: Array<MedicalInfoContinualPostoperativeInner>;
  /**
   *
   * @type {Array<MedicalInfoTreatmentInner>}
   * @memberof MedicalInfo
   */
  treatment?: Array<MedicalInfoTreatmentInner>;
  /**
   *
   * @type {string}
   * @memberof MedicalInfo
   */
  creationDatetime?: string;
}
/**
 *
 * @export
 * @interface MedicalInfoContinualPostoperativeInner
 */
export interface MedicalInfoContinualPostoperativeInner {
  /**
   *
   * @type {string}
   * @memberof MedicalInfoContinualPostoperativeInner
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoContinualPostoperativeInner
   */
  parameterControl?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoContinualPostoperativeInner
   */
  care?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoContinualPostoperativeInner
   */
  medicines?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoContinualPostoperativeInner
   */
  followup?: string;
}
/**
 *
 * @export
 * @interface MedicalInfoTreatmentInner
 */
export interface MedicalInfoTreatmentInner {
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  disease?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  stage?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  treatmentStart?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  treatmentEnd?: string;
  /**
   * hospital name
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  hospital?: string;
  /**
   *
   * @type {string}
   * @memberof MedicalInfoTreatmentInner
   */
  doctorName?: string;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   *
   * @type {string}
   * @memberof Message
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  senderId?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  receiverId?: string;
  /**
   *
   * @type {string}
   * @memberof Message
   */
  content?: string;
  /**
   *
   * @type {File}
   * @memberof Message
   */
  attachment?: File;
}
/**
 *
 * @export
 * @interface NotAuthorizedException
 */
export interface NotAuthorizedException {
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof NotAuthorizedException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface Patient
 */
export interface Patient {
  /**
   * Current doctor
   * @type {string}
   * @memberof Patient
   */
  doctorId?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  documentId?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  authenticationId?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  birthDate?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  photoId?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  sex?: PatientSexEnum;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  contact?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof Patient
   */
  role?: PatientRoleEnum;
}

export const PatientSexEnum = {
  Male: 'MALE',
  Feminine: 'FEMININE',
} as const;

export type PatientSexEnum = (typeof PatientSexEnum)[keyof typeof PatientSexEnum];
export const PatientRoleEnum = {
  Advisor: 'ADVISOR',
  Doctor: 'DOCTOR',
  Patient: 'PATIENT',
} as const;

export type PatientRoleEnum = (typeof PatientRoleEnum)[keyof typeof PatientRoleEnum];

/**
 *
 * @export
 * @interface PatientAdditionalInfo
 */
export interface PatientAdditionalInfo {
  /**
   *
   * @type {string}
   * @memberof PatientAdditionalInfo
   */
  profession?: string;
  /**
   *
   * @type {string}
   * @memberof PatientAdditionalInfo
   */
  educationLevel?: string;
  /**
   *
   * @type {string}
   * @memberof PatientAdditionalInfo
   */
  civilStatus?: PatientAdditionalInfoCivilStatusEnum;
  /**
   *
   * @type {string}
   * @memberof PatientAdditionalInfo
   */
  bloodType?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PatientAdditionalInfo
   */
  allergies?: Array<string>;
}

export const PatientAdditionalInfoCivilStatusEnum = {
  Bachelor: 'BACHELOR',
  Engaged: 'ENGAGED',
  Married: 'MARRIED',
  Other: 'OTHER',
} as const;

export type PatientAdditionalInfoCivilStatusEnum = (typeof PatientAdditionalInfoCivilStatusEnum)[keyof typeof PatientAdditionalInfoCivilStatusEnum];

/**
 *
 * @export
 * @interface ResourceNotFoundException
 */
export interface ResourceNotFoundException {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface TooManyRequestsException
 */
export interface TooManyRequestsException {
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof TooManyRequestsException
   */
  message?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  authenticationId?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthDate?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  photoId?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  sex?: UserSexEnum;
  /**
   *
   * @type {string}
   * @memberof User
   */
  contact?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role?: UserRoleEnum;
}

export const UserSexEnum = {
  Male: 'MALE',
  Feminine: 'FEMININE',
} as const;

export type UserSexEnum = (typeof UserSexEnum)[keyof typeof UserSexEnum];
export const UserRoleEnum = {
  Advisor: 'ADVISOR',
  Doctor: 'DOCTOR',
  Patient: 'PATIENT',
} as const;

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum];

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Crupdate appointment
     * @param {string} id
     * @param {Appointment} [appointment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAppointment: async (id: string, appointment?: Appointment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('crupdateAppointment', 'id', id);
      const localVarPath = `/appointments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(appointment, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Crupdate a medical information
     * @param {string} id
     * @param {MedicalInfo} [medicalInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateMedicalInfo: async (id: string, medicalInfo?: MedicalInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('crupdateMedicalInfo', 'id', id);
      const localVarPath = `/patients/{id}/medicalInfo`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(medicalInfo, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all appointments of a doctor
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorAppointments: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoctorAppointments', 'id', id);
      const localVarPath = `/doctors/{id}/appointments`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get feedbacks of a specific doctors
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorFeedbacks: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoctorFeedbacks', 'id', id);
      const localVarPath = `/doctors/{id}/feedbacks`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all appointments of a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsAppointments: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPatientsAppointments', 'id', id);
      const localVarPath = `/patients/{id}/appointments`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Give feedback to a specific doctor
     * @param {string} id
     * @param {Feedback} [feedback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    giveFeedBacks: async (id: string, feedback?: Feedback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('giveFeedBacks', 'id', id);
      const localVarPath = `/doctors/{id}/feedbacks`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read an appointment
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAppointment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readAppointment', 'id', id);
      const localVarPath = `/appointments/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read medical information about a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMedicalInfo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('readMedicalInfo', 'id', id);
      const localVarPath = `/patients/{id}/medicalInfo`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Crupdate appointment
     * @param {string} id
     * @param {Appointment} [appointment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateAppointment(
      id: string,
      appointment?: Appointment,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateAppointment(id, appointment, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.crupdateAppointment']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Crupdate a medical information
     * @param {string} id
     * @param {MedicalInfo} [medicalInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateMedicalInfo(id: string, medicalInfo?: MedicalInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateMedicalInfo(id, medicalInfo, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.crupdateMedicalInfo']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get all appointments of a doctor
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctorAppointments(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorAppointments(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.getDoctorAppointments']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get feedbacks of a specific doctors
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctorFeedbacks(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackSummary>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorFeedbacks(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.getDoctorFeedbacks']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get all appointments of a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPatientsAppointments(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientsAppointments(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.getPatientsAppointments']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Give feedback to a specific doctor
     * @param {string} id
     * @param {Feedback} [feedback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async giveFeedBacks(id: string, feedback?: Feedback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.giveFeedBacks(id, feedback, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.giveFeedBacks']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Read an appointment
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readAppointment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readAppointment(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.readAppointment']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Read medical information about a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readMedicalInfo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readMedicalInfo(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ActivityApi.readMedicalInfo']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ActivityApiFp(configuration);
  return {
    /**
     *
     * @summary Crupdate appointment
     * @param {string} id
     * @param {Appointment} [appointment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAppointment(id: string, appointment?: Appointment, options?: any): AxiosPromise<Appointment> {
      return localVarFp.crupdateAppointment(id, appointment, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Crupdate a medical information
     * @param {string} id
     * @param {MedicalInfo} [medicalInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateMedicalInfo(id: string, medicalInfo?: MedicalInfo, options?: any): AxiosPromise<File> {
      return localVarFp.crupdateMedicalInfo(id, medicalInfo, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get all appointments of a doctor
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorAppointments(id: string, options?: any): AxiosPromise<Array<Appointment>> {
      return localVarFp.getDoctorAppointments(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get feedbacks of a specific doctors
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorFeedbacks(id: string, options?: any): AxiosPromise<FeedbackSummary> {
      return localVarFp.getDoctorFeedbacks(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get all appointments of a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsAppointments(id: string, options?: any): AxiosPromise<Array<Appointment>> {
      return localVarFp.getPatientsAppointments(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Give feedback to a specific doctor
     * @param {string} id
     * @param {Feedback} [feedback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    giveFeedBacks(id: string, feedback?: Feedback, options?: any): AxiosPromise<Feedback> {
      return localVarFp.giveFeedBacks(id, feedback, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Read an appointment
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAppointment(id: string, options?: any): AxiosPromise<Appointment> {
      return localVarFp.readAppointment(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Read medical information about a patient
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMedicalInfo(id: string, options?: any): AxiosPromise<File> {
      return localVarFp.readMedicalInfo(id, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
  /**
   *
   * @summary Crupdate appointment
   * @param {string} id
   * @param {Appointment} [appointment]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public crupdateAppointment(id: string, appointment?: Appointment, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .crupdateAppointment(id, appointment, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Crupdate a medical information
   * @param {string} id
   * @param {MedicalInfo} [medicalInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public crupdateMedicalInfo(id: string, medicalInfo?: MedicalInfo, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .crupdateMedicalInfo(id, medicalInfo, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all appointments of a doctor
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public getDoctorAppointments(id: string, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .getDoctorAppointments(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get feedbacks of a specific doctors
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public getDoctorFeedbacks(id: string, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .getDoctorFeedbacks(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all appointments of a patient
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public getPatientsAppointments(id: string, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .getPatientsAppointments(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Give feedback to a specific doctor
   * @param {string} id
   * @param {Feedback} [feedback]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public giveFeedBacks(id: string, feedback?: Feedback, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .giveFeedBacks(id, feedback, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read an appointment
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public readAppointment(id: string, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .readAppointment(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read medical information about a patient
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityApi
   */
  public readMedicalInfo(id: string, options?: RawAxiosRequestConfig) {
    return ActivityApiFp(this.configuration)
      .readMedicalInfo(id, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CommunicationApi - axios parameter creator
 * @export
 */
export const CommunicationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Crupdate channel
     * @param {string} id
     * @param {Channel} [channel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateChannel: async (id: string, channel?: Channel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('crupdateChannel', 'id', id);
      const localVarPath = `/channel/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(channel, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Crupdate a message for channel
     * @param {string} id
     * @param {string} mId
     * @param {Message} [message]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateMessage: async (id: string, mId: string, message?: Message, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('crupdateMessage', 'id', id);
      // verify required parameter 'mId' is not null or undefined
      assertParamExists('crupdateMessage', 'mId', mId);
      const localVarPath = `/channels/{id}/messages/{mId}`.replace(`{${'id'}}`, encodeURIComponent(String(id))).replace(`{${'mId'}}`, encodeURIComponent(String(mId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user channels
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getChannels', 'id', id);
      const localVarPath = `/users/{id}/channels`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get channel\'s messages
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageByChannelId: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getMessageByChannelId', 'id', id);
      const localVarPath = `/channels/{id}/messages`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommunicationApi - functional programming interface
 * @export
 */
export const CommunicationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CommunicationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Crupdate channel
     * @param {string} id
     * @param {Channel} [channel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateChannel(id: string, channel?: Channel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateChannel(id, channel, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommunicationApi.crupdateChannel']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Crupdate a message for channel
     * @param {string} id
     * @param {string} mId
     * @param {Message} [message]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateMessage(
      id: string,
      mId: string,
      message?: Message,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateMessage(id, mId, message, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommunicationApi.crupdateMessage']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get user channels
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannels(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannels(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommunicationApi.getChannels']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get channel\'s messages
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessageByChannelId(
      id: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageByChannelId(id, page, pageSize, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommunicationApi.getMessageByChannelId']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CommunicationApi - factory interface
 * @export
 */
export const CommunicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CommunicationApiFp(configuration);
  return {
    /**
     *
     * @summary Crupdate channel
     * @param {string} id
     * @param {Channel} [channel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateChannel(id: string, channel?: Channel, options?: any): AxiosPromise<Channel> {
      return localVarFp.crupdateChannel(id, channel, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Crupdate a message for channel
     * @param {string} id
     * @param {string} mId
     * @param {Message} [message]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateMessage(id: string, mId: string, message?: Message, options?: any): AxiosPromise<Message> {
      return localVarFp.crupdateMessage(id, mId, message, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get user channels
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels(id: string, options?: any): AxiosPromise<Array<Channel>> {
      return localVarFp.getChannels(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get channel\'s messages
     * @param {string} id
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessageByChannelId(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<Message>> {
      return localVarFp.getMessageByChannelId(id, page, pageSize, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * CommunicationApi - object-oriented interface
 * @export
 * @class CommunicationApi
 * @extends {BaseAPI}
 */
export class CommunicationApi extends BaseAPI {
  /**
   *
   * @summary Crupdate channel
   * @param {string} id
   * @param {Channel} [channel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationApi
   */
  public crupdateChannel(id: string, channel?: Channel, options?: RawAxiosRequestConfig) {
    return CommunicationApiFp(this.configuration)
      .crupdateChannel(id, channel, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Crupdate a message for channel
   * @param {string} id
   * @param {string} mId
   * @param {Message} [message]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationApi
   */
  public crupdateMessage(id: string, mId: string, message?: Message, options?: RawAxiosRequestConfig) {
    return CommunicationApiFp(this.configuration)
      .crupdateMessage(id, mId, message, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user channels
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationApi
   */
  public getChannels(id: string, options?: RawAxiosRequestConfig) {
    return CommunicationApiFp(this.configuration)
      .getChannels(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get channel\'s messages
   * @param {string} id
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationApi
   */
  public getMessageByChannelId(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
    return CommunicationApiFp(this.configuration)
      .getMessageByChannelId(id, page, pageSize, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * DepartmentApi - axios parameter creator
 * @export
 */
export const DepartmentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Crupdate hospital
     * @param {Array<Hospital>} [hospital]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateHospital: async (hospital?: Array<Hospital>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hospitals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hospital, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of doctors of a specific department
     * @param {string} id hospital identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorsByHospitalsId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoctorsByHospitalsId', 'id', id);
      const localVarPath = `/department/{id}/doctors`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of hospitals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHospitals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/hospitals`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DepartmentApi - functional programming interface
 * @export
 */
export const DepartmentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DepartmentApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Crupdate hospital
     * @param {Array<Hospital>} [hospital]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateHospital(hospital?: Array<Hospital>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hospital>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateHospital(hospital, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DepartmentApi.crupdateHospital']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get list of doctors of a specific department
     * @param {string} id hospital identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctorsByHospitalsId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Doctor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorsByHospitalsId(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DepartmentApi.getDoctorsByHospitalsId']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get list of hospitals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHospitals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hospital>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHospitals(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DepartmentApi.getHospitals']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DepartmentApi - factory interface
 * @export
 */
export const DepartmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DepartmentApiFp(configuration);
  return {
    /**
     *
     * @summary Crupdate hospital
     * @param {Array<Hospital>} [hospital]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateHospital(hospital?: Array<Hospital>, options?: any): AxiosPromise<Array<Hospital>> {
      return localVarFp.crupdateHospital(hospital, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of doctors of a specific department
     * @param {string} id hospital identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorsByHospitalsId(id: string, options?: any): AxiosPromise<Array<Doctor>> {
      return localVarFp.getDoctorsByHospitalsId(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of hospitals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHospitals(options?: any): AxiosPromise<Array<Hospital>> {
      return localVarFp.getHospitals(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * DepartmentApi - object-oriented interface
 * @export
 * @class DepartmentApi
 * @extends {BaseAPI}
 */
export class DepartmentApi extends BaseAPI {
  /**
   *
   * @summary Crupdate hospital
   * @param {Array<Hospital>} [hospital]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DepartmentApi
   */
  public crupdateHospital(hospital?: Array<Hospital>, options?: RawAxiosRequestConfig) {
    return DepartmentApiFp(this.configuration)
      .crupdateHospital(hospital, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of doctors of a specific department
   * @param {string} id hospital identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DepartmentApi
   */
  public getDoctorsByHospitalsId(id: string, options?: RawAxiosRequestConfig) {
    return DepartmentApiFp(this.configuration)
      .getDoctorsByHospitalsId(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of hospitals
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DepartmentApi
   */
  public getHospitals(options?: RawAxiosRequestConfig) {
    return DepartmentApiFp(this.configuration)
      .getHospitals(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve file
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadFile', 'fileId', fileId);
      const localVarPath = `/raw/{fileId}`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload standard file
     * @param {string} fileId
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile: async (fileId: string, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('uploadFile', 'fileId', fileId);
      const localVarPath = `/raw/{fileId}`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'image/*';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve file
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FileApi.downloadFile']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Upload standard file
     * @param {string} fileId
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadFile(fileId: string, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(fileId, body, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FileApi.uploadFile']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FileApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve file
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(fileId: string, options?: any): AxiosPromise<File> {
      return localVarFp.downloadFile(fileId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Upload standard file
     * @param {string} fileId
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(fileId: string, body?: File, options?: any): AxiosPromise<string> {
      return localVarFp.uploadFile(fileId, body, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
  /**
   *
   * @summary Retrieve file
   * @param {string} fileId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileApi
   */
  public downloadFile(fileId: string, options?: RawAxiosRequestConfig) {
    return FileApiFp(this.configuration)
      .downloadFile(fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload standard file
   * @param {string} fileId
   * @param {File} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FileApi
   */
  public uploadFile(fileId: string, body?: File, options?: RawAxiosRequestConfig) {
    return FileApiFp(this.configuration)
      .uploadFile(fileId, body, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HealthApi.ping']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     * Check server health
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp.ping(options).then(request => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Check server health
   * @summary Health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Generate token for a video call
     * @param {GenerateTokenRequest} [generateTokenRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateToken: async (generateTokenRequest?: GenerateTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/call/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(generateTokenRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/signin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sign up user
     * @param {User} user Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists('signUp', 'user', user);
      const localVarPath = `/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Generate token for a video call
     * @param {GenerateTokenRequest} [generateTokenRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateToken(
      generateTokenRequest?: GenerateTokenRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateToken200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateToken(generateTokenRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SecurityApi.generateToken']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SecurityApi.signIn']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Sign up user
     * @param {User} user Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signUp(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(user, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SecurityApi.signUp']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary Generate token for a video call
     * @param {GenerateTokenRequest} [generateTokenRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateToken(generateTokenRequest?: GenerateTokenRequest, options?: any): AxiosPromise<GenerateToken200Response> {
      return localVarFp.generateToken(generateTokenRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Login user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(options?: any): AxiosPromise<User> {
      return localVarFp.signIn(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Sign up user
     * @param {User} user Sign up payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp(user: User, options?: any): AxiosPromise<User> {
      return localVarFp.signUp(user, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary Generate token for a video call
   * @param {GenerateTokenRequest} [generateTokenRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public generateToken(generateTokenRequest?: GenerateTokenRequest, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .generateToken(generateTokenRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signIn(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signIn(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Sign up user
   * @param {User} user Sign up payload.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signUp(user: User, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signUp(user, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Crupdate doctor
     * @param {string} id
     * @param {Doctor} [doctor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateDoctor: async (id: string, doctor?: Doctor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('crupdateDoctor', 'id', id);
      const localVarPath = `/doctors/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(doctor, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get doctors by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getDoctorById', 'id', id);
      const localVarPath = `/doctors/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of doctors
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctors: async (firstName?: string, lastName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/doctors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName;
      }

      if (lastName !== undefined) {
        localVarQueryParameter['lastName'] = lastName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get patient by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPatientById', 'id', id);
      const localVarPath = `/patients/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get patients of a specific doctor
     * @param {string} id
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsByDoctorId: async (id: string, firstName?: string, lastName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPatientsByDoctorId', 'id', id);
      const localVarPath = `/doctors/{id}/patients`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName;
      }

      if (lastName !== undefined) {
        localVarQueryParameter['lastName'] = lastName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user photo
     * @param {string} id
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePic: async (id: string, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateProfilePic', 'id', id);
      const localVarPath = `/users/{id}/raw`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'image/*';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Crupdate doctor
     * @param {string} id
     * @param {Doctor} [doctor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateDoctor(id: string, doctor?: Doctor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Doctor>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateDoctor(id, doctor, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.crupdateDoctor']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get doctors by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctorById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Doctor>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctorById(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getDoctorById']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get list of doctors
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDoctors(firstName?: string, lastName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Doctor>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDoctors(firstName, lastName, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getDoctors']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get patient by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPatientById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Patient>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientById(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getPatientById']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get patients of a specific doctor
     * @param {string} id
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPatientsByDoctorId(
      id: string,
      firstName?: string,
      lastName?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Patient>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPatientsByDoctorId(id, firstName, lastName, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.getPatientsByDoctorId']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Update user photo
     * @param {string} id
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfilePic(id: string, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfilePic(id, body, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.updateProfilePic']?.[index]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @summary Crupdate doctor
     * @param {string} id
     * @param {Doctor} [doctor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateDoctor(id: string, doctor?: Doctor, options?: any): AxiosPromise<Doctor> {
      return localVarFp.crupdateDoctor(id, doctor, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get doctors by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctorById(id: string, options?: any): AxiosPromise<Doctor> {
      return localVarFp.getDoctorById(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get list of doctors
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDoctors(firstName?: string, lastName?: string, options?: any): AxiosPromise<Array<Doctor>> {
      return localVarFp.getDoctors(firstName, lastName, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get patient by identifier
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientById(id: string, options?: any): AxiosPromise<Patient> {
      return localVarFp.getPatientById(id, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Get patients of a specific doctor
     * @param {string} id
     * @param {string} [firstName]
     * @param {string} [lastName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsByDoctorId(id: string, firstName?: string, lastName?: string, options?: any): AxiosPromise<Array<Patient>> {
      return localVarFp.getPatientsByDoctorId(id, firstName, lastName, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Update user photo
     * @param {string} id
     * @param {File} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePic(id: string, body?: File, options?: any): AxiosPromise<string> {
      return localVarFp.updateProfilePic(id, body, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Crupdate doctor
   * @param {string} id
   * @param {Doctor} [doctor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public crupdateDoctor(id: string, doctor?: Doctor, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .crupdateDoctor(id, doctor, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get doctors by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getDoctorById(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getDoctorById(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get list of doctors
   * @param {string} [firstName]
   * @param {string} [lastName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getDoctors(firstName?: string, lastName?: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getDoctors(firstName, lastName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get patient by identifier
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getPatientById(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getPatientById(id, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get patients of a specific doctor
   * @param {string} id
   * @param {string} [firstName]
   * @param {string} [lastName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getPatientsByDoctorId(id: string, firstName?: string, lastName?: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getPatientsByDoctorId(id, firstName, lastName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user photo
   * @param {string} id
   * @param {File} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateProfilePic(id: string, body?: File, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .updateProfilePic(id, body, options)
      .then(request => request(this.axios, this.basePath));
  }
}
